classdef gMOEADGGRAW_EIE < ALGORITHM
% <multi/many> <real>
% gMOEA/D-GGRAW
% delta --- 0.8 --- The probability of selecting candidates from neighborhood
% p --- 1 --- The parameter p of GNS
% Tm --- 0.1 --- The mating neighborhood size
% Tr --- 0.001 --- The replacement neighborhood size
% alpha_cone --- 0.1 --- Parameter of cone dominance
% tol --- 0.05 --- Parameter of the EWS method
% is_EIE --- 1 --- 
% 
%   Author: Ruihao Zheng

    methods
        function main(Algorithm,Problem)
            %% Parameter setting
            [delta, p, Tm, Tr, alpha_cone, tol, is_EIE] = Algorithm.ParameterSet(0.8, 1, 0.1, 0.001, 0.1, 0.05, 1);
            if length(tol) == 1
                tol = tol*ones(1,Problem.M);
            end

            %% Init MOEA
            % Generate the weight vectors
            [W, Problem.N] = UniformPoint(Problem.N, Problem.M);
            Tm = ceil(Problem.N * Tm);
            Tr = ceil(Problem.N * Tr);
            % Detect the mating and replacement neighbors of each solution
            B = pdist2(W, W);
            W = 1./W ./ sum(1./W, 2);
            [~,B] = sort(B, 2);
            Bm = B(:, 1:Tm);
            % Generate random population
            Population = Problem.Initialization();
            % Initialize the reference point
            [zmin, I] = min(Population.objs, [], 1);
            % Dertermine the scalar function
            switch p
                case 1
                    type = 1.2;
                case inf
                    type = 2;
                otherwise
                    type = 7 + min(999, p)*0.001;
            end
            h = (prod(W,2).^(-1/Problem.M));
            % Repair the boundary weight generated by "UniformPoint"    not required since "W = 1./W ./ sum(1./W, 2);" 
            % zero_counter = sum(W<=1e-6, 2);
            % [~, I] = max(W, [], 2);
            % for i = 1 : Problem.N
            %     W(i, I(i)) = W(i, I(i)) - zero_counter(i)*1e-6;
            % end
            % Generate an archive set
            Archive = Population(NDSort(Population.objs,1)==1);

            %% Init EIE
            % Parameters of CMA-ES
            if is_EIE
                state_CMAES = ones(1, Problem.M);  % ==1: activated; >=2: deactivated
            else
                state_CMAES = inf(1, Problem.M);
            end
            lambda_def = 4+floor(3*log(Problem.D));
            x_range = Problem.upper-Problem.lower;
            Sigma = struct('s',num2cell(1:Problem.M),'lambda',lambda_def,'m',num2cell(Population(I).decs,2)', ...
                'sigma',0.5*norm(diag(x_range)),'sigma_0',0.5*norm(diag(x_range)), ...  % 不能为0，会使得下次更新出现nan值
                'C',diag(x_range/norm(diag(x_range))),'diagD_0',(x_range/norm(diag(x_range))'), ...  % 考虑变量量纲不一致，并确保该对角阵二范数等于单位阵的二范数
                'p_c',0,'p_sigma',0,'gen',0,'gen_TolFun',0,'PSA_buff',[]);

            % Warm-start CMA-ES
            alpha = (tol*Problem.M) ./ (Problem.M-1-tol*(1-Problem.M));  % The meaning of alpha in the code differs slightly from that described in the paper; however, it is equivalent.
            WS_gamma = 0.1*ones(1,Problem.M);
            WS_alpha = 0.1*ones(1,Problem.M);
            objs_pop = Population.objs;
            objs_pop = normalize_2(objs_pop, zmin, max(Population.objs,[],1));
            objs_pop_trans = g_ews(objs_pop, objs_pop, alpha);
            for i = 1 : Problem.M
                [Sigma(i).m, Sigma(i).sigma, Sigma(i).C] = warm_start([Population.decs, objs_pop_trans(:,i)], WS_gamma(i), WS_alpha(i));
                Sigma(i).sigma_0 = Sigma(i).sigma;
                [~,D] = eig(Sigma(i).C);
                Sigma(i).diagD_0 = diag(D);
            end
            
            %% Optimization
            while Algorithm.NotTerminated(Population)
                % Generate offspring by EIE
                Offspring = [];
                Combine = cell(1, Problem.M);
                flag_inj = cell(1, Problem.M);
                for i = 1 : Problem.M
                    if state_CMAES(i) < 2
                        points_sampling = mvnrnd(Sigma(i).m,Sigma(i).sigma^2*Sigma(i).C,Sigma(i).lambda);
                        flag_inj{i} = any(points_sampling < Problem.lower, 2) | any(points_sampling > Problem.upper, 2);  % box constraints
                        Offspring_i = SOLUTION( min(max(points_sampling,Problem.lower),Problem.upper) );
                        Offspring = [Offspring Offspring_i];
                        Combine{i} = Offspring_i;
                    end
                end


                % Iteration of MOEA
                % Get the mating pool
                MatingPool = zeros(1, 2 * Problem.N);
                for i = 1 : Problem.N
                    % Choose the parents
                    if rand < delta
                        P = Bm(i, randperm(Tm));
                    else
                        P = randperm(Problem.N);
                    end
                    MatingPool(i) = P(1);
                    MatingPool(Problem.N + i) = P(2);
                end
                
                % Generate N offspring and merge all the offspring
                Offspring = [
                    Offspring, ...
                    OperatorDE(Population, ...
                               Population(MatingPool(1:length(MatingPool)/2)),Population(MatingPool(length(MatingPool)/2+1:end)), ...
                               {0.9,0.5,1,50})
                    ];

                % Replacement
                zmin = min([zmin; Offspring.objs]);
                zmax = max(Archive.objs, [], 1);
                Pt = [Population Offspring];
                objs_n = normalize_2(Pt.objs, zmin, zmax);  % normalization
                g = zeros(length(Pt), Problem.N);
                for i = 1 : length(Pt)
                    g(i,:) = calSubpFitness(type, objs_n(i,:), zeros(1,Problem.M), W) .* h;
                end
                [~, I_subp] = min(g, [], 2);
                index_Pt = zeros(Problem.N, 1);
                select_counter = zeros(size(objs_n,1),1);
                for i = 1 : Problem.N
                    closest = find(I_subp==i & select_counter<Tr);
                    if isempty(closest)
                        [~,index_Pt(i)] = min(g(:,i));  % greedy
                        continue
                    end
                    [~, Ri] = min(g(closest, i));
                    index_Pt(i) = closest(Ri);
                    select_counter(closest(Ri)) = select_counter(closest(Ri)) + 1;
                end
                Population = Pt(index_Pt);

                % Maintenance operation in the archive set
                Archive = [Archive,Offspring];
                Archive = ArchiveUpdate(Archive,2*Problem.N,zmin,zmax,alpha_cone);

                % Update weights
                if ~mod(ceil(Problem.FE/Problem.N),ceil(0.05*ceil(Problem.maxFE/Problem.N))) && Problem.FE <= Problem.maxFE*0.9
                    if length(Archive) > 1
                        [Population,W,h,B] = WeightUpdate(Population,W,1./W./sum(1./W,2),type,h,Archive,zmin,zmax,Tr,Problem);
                        Bm = B(:, 1:Tm);
                        % plot3(W_dir(:,1),W_dir(:,2),W_dir(:,3),'*'), view(135,30), grid on
                    end
                end


                % Update EIE
                objs_off = Offspring.objs;
                objs_off = normalize_2(objs_off, zmin, zmax);
                objs_off_trans = g_ews(objs_off, objs_off, alpha);
                [~, I] = sort(objs_off_trans, 1);
                for i = 1 : Problem.M
                    % Fitness value stagnation detection
                    if state_CMAES(i) < 2
                        if ~exist('sol_fitness_best', 'var')
                            sol_fitness_best = Offspring(I(1,:));
                        else
                            objs_sfb = sol_fitness_best(i).obj;
                            objs_sfb = normalize_2(objs_sfb, zmin, zmax);
                            objs_sfb_trans_part = g_ews(objs_sfb(i),objs_sfb,alpha(i));
                            if objs_sfb_trans_part > objs_off_trans(I(1,i),i)
                                sol_fitness_best(i) = Offspring(I(1,i));
                                objs_sfb = sol_fitness_best(i).obj;
                                objs_sfb = normalize_2(objs_sfb, zmin, zmax);
                                objs_sfb_trans_part = g_ews(objs_sfb(i),objs_sfb,alpha(i));
                            end
                            objs_comb = Combine{i}.objs;
                            objs_comb = normalize_2(objs_comb, zmin, zmax);
                            diff_comb_sfb = g_ews(objs_comb(:,i), objs_comb, alpha(i)) - objs_sfb_trans_part;
                            if all(diff_comb_sfb < 1e-3)  % default 1e-12
                                Sigma(i).gen_TolFun = Sigma(i).gen_TolFun + 1;
                            else
                                Sigma(i).gen_TolFun = 0;
                            end
                        end
                    end
                    % Inject good solutions from the other new solutions
                    if state_CMAES(i) < 2 && Sigma(i).lambda == lambda_def  % 首先快速收敛，之后为了避免陷入局部最优，不允许injection
                        objs_comb = Combine{i}.objs;
                        [~,ia_objs_comb,ib_objs_off_top] = intersect(objs_comb,objs_off(I(1:Sigma(i).lambda,i),:),'stable','rows');
                        if length(ia_objs_comb) < Sigma(i).lambda  % 不是该CMA-ES产生的好解的逻辑索引存在1
                            index_objs_off_top = I(1:Sigma(i).lambda,i);
                            Combine{i} = [Combine{i}(ia_objs_comb) Offspring(index_objs_off_top(setdiff(1:Sigma(i).lambda,ib_objs_off_top,'stable')))];
                            flag_inj{i} = [flag_inj{i}(ia_objs_comb); true(Sigma(i).lambda-length(ib_objs_off_top),1)];
                        end
                    end
                end
                for i = 1 : Problem.M
                    if state_CMAES(i) < 2
                        % Sort the offsprings and injected solutions
                        objs_comb = Combine{i}.objs;
                        objs_comb = normalize_2(objs_comb, zmin, zmax);
                        objs_comb_trans_part = g_ews(objs_comb(:,i), objs_comb, alpha(i));
                        [~,rank] = sort(objs_comb_trans_part);
                        % Update CMA-ES
                        [Sigma(i), exitflag] = update_CMAES(Sigma(i),Combine{i}(rank).decs,lambda_def,flag_inj{i}(rank));
                        switch exitflag
                            case 0
                            case {-1, 1}
                                switch exitflag
                                    case -1
                                        state_CMAES(i) = state_CMAES(i) + 1;
                                    case 1
                                        % need restart
                                end
                                Sigma(i).s = i;
                                objs_pop = Population.objs;
                                objs_pop = normalize_2(objs_pop, zmin, zmax);
                                objs_pop_trans_part = g_ews(objs_pop(:,i), objs_pop, alpha(i));
                                % Restart
                                % [~, I] = min(objs_pop_trans_part);
                                % Sigma(i).m = Population(I).dec;
                                % x_range = Problem.upper-Problem.lower;
                                % Sigma(i).sigma = 0.5*norm(diag(x_range));
                                % Sigma(i).C = diag(x_range/norm(diag(x_range)));
                                % Warm restart
                                [Sigma(i).m, Sigma(i).sigma, Sigma(i).C] = warm_start([Population.decs, objs_pop_trans_part], WS_gamma(i), WS_alpha(i));
                                Sigma(i).sigma_0 = Sigma(i).sigma;
                                [~,D] = eig(Sigma(i).C);
                                Sigma(i).diagD_0 = diag(D);
                        end
                    end
                end
            end
        end
    end
end


%%
function [Population,W,h,B] = WeightUpdate(Population,W,W_dir,type,h,Archive,zmin,zmax,T,Problem)
% Weight Update
% Modified by Ruihao Zheng

%------------------------------- Copyright --------------------------------
% Copyright (c) 2024 BIMK Group. You are free to use the PlatEMO for
% research purposes. All publications which use this platform or any code
% in the platform should acknowledge the use of "PlatEMO" and reference "Ye
% Tian, Ran Cheng, Xingyi Zhang, and Yaochu Jin, PlatEMO: A MATLAB platform
% for evolutionary multi-objective optimization [educational forum], IEEE
% Computational Intelligence Magazine, 2017, 12(4): 73-87".
%--------------------------------------------------------------------------

    % Routine to find undeveloped individuals (correspondingly their weights) in the archive set
    % Normalisation
    N_arc = length(Archive);
    Archiveobjs = (Archive.objs-repmat(zmin,N_arc,1) ) ./ repmat(zmax-zmin,N_arc,1);
    Populationobjs = (Population.objs - repmat(zmin,Problem.N,1) )./repmat(zmax - zmin,Problem.N,1);
    zmin = (zmin-zmin)./(zmax-zmin);  % 实际上为0，计算标量化函数值的zmin可以不用去掉
    % Euclidean distance between individuals in the archive set and individuals in the Population
    dis1 = pdist2(Archiveobjs,Populationobjs);
    dis1 = sort(dis1,2);
    % Euclidean distance between any two individuals in the archive set
    dis2 = pdist2(Archiveobjs,Archiveobjs);
    dis2 = sort(dis2,2);
    % Calculate the niche size(median of the distances from their closest solution in the archive )
    niche_size = median(dis2(:,2));
    % Find undeveloped 
    index = dis1(:,1) >= niche_size;
    Archive_und = Archive(index);
    Archiveundobjs = Archiveobjs(index,:);  % not re-normalize since it is a significantly biased subset
    
    % If the undeveloped individuals are promising then add them into the evolutionary Population         
    % Obtain their corresponding weights.
    if ~isempty(Archive_und)
        W1_dir = (Archiveundobjs-zmin) ./ sum(Archiveundobjs-zmin,2);
        W1_dir(W1_dir==0) = 1e-6;  % avoid nan in W1
        W1 = 1./W1_dir./sum(W1_dir,2);
        h1 = (prod(W1,2).^(-1/Problem.M));
        for i = 1 : size(W1_dir,1)
            W_all = [W_dir;W1_dir(i,:)];
            B1 = pdist2(W_all,W_all);
            B1(logical(eye(length(B1)))) = inf;
            [~,B1] = sort(B1,2);
            B1 = B1(:,1:T);

            Population1objs = [Populationobjs;Archiveundobjs(i,:)];
            Population2objs = Population1objs(B1(end,:),:);

            Value_GLp_all = calSubpFitness(type, Population2objs, zeros(1,Problem.M), W1(i,:)) .* h1(i);
            Value_GLp     = calSubpFitness(type, Archiveundobjs(i,:), zeros(1,Problem.M), W1(i,:)) .* h1(i);

            index = find(Value_GLp_all<Value_GLp, 1);

            if isempty(index)
                % Put the wight into the W, as well as the corresponding solution
                W_dir = [W_dir; W1_dir(i,:)];
                W = [W; W1(i,:)];
                h = [h; h1(i)];
                Population = [Population Archive_und(i)];
                Populationobjs = [Populationobjs; Archiveundobjs(i,:)];

                % Update neighbour solutions after adding a weight
                P = B1(end,:);
                g_old = calSubpFitness(type, Populationobjs(P,:), zeros(1,Problem.M), W(P,:)) .* h(P);
                g_new = calSubpFitness(type, Archiveundobjs(i,:), zeros(1,Problem.M), W(P,:)) .* h(P);
                index2 = P(g_old > g_new);
                Population(index2) = Archive_und(i);
                Populationobjs(index2,:) = repmat(Archiveundobjs(i,:),length(index2),1);
            end
        end
    end
    
    % Delete the poorly performed weights until the size of W is reduced to N
    % find out the solution that is shared by the most weights in the population
    while length(Population) > Problem.N
        [~,ai,bi] = unique(Population.objs,'rows');
        PCObj = (Population.objs-repmat(zmin,length(Population),1))./repmat(zmax-zmin,length(Population),1);
        if length(ai) == length(bi)   % If every solution in the population corresponds to only one weight
            % Determine the radius of the niche
            d  = pdist2(PCObj,PCObj);
            d(logical(eye(length(d)))) = inf;
            sd = sort(d,2);
            num_obj = size(Population.objs,2);
            r  = median(sd(:,min(num_obj,size(sd,2))));
            R  = min(d./r,1);
            % Delete solution one by one
            while length(Population) > Problem.N
                [~,worst]  = max(1-prod(R,2));
                Population(worst)  = [];
                PCObj(worst,:) = [];
                R(worst,:) = [];
                R(:,worst) = [];
                W_dir(worst,:) = [];
                W(worst,:) = [];
                h(worst) = [];
            end
        else
            index = find(bi==mode(bi));
            Value_GLp2 = calSubpFitness(type, PCObj(index,:), zeros(1,Problem.M), W(index,:)) .* h(index);
            
            Index_max= find(Value_GLp2 == max(Value_GLp2));
            Population(index(Index_max(1)))=[];
            W_dir(index(Index_max(1)),:)=[];
            W(index(Index_max(1)),:)=[];
            h(index(Index_max(1)))=[];
        end
    end
    % Update the neighbours of each weight
    B = pdist2(W_dir,W_dir);
    [~,B] = sort(B,2);
    % B = B(:,1:T);
end


function Archive = ArchiveUpdate(Archive,N,zmin,zmax,rho_cone)
% Archive Update
% Modified by Ruihao Zheng

%------------------------------- Copyright --------------------------------
% Copyright (c) 2024 BIMK Group. You are free to use the PlatEMO for
% research purposes. All publications which use this platform or any code
% in the platform should acknowledge the use of "PlatEMO" and reference "Ye
% Tian, Ran Cheng, Xingyi Zhang, and Yaochu Jin, PlatEMO: A MATLAB platform
% for evolutionary multi-objective optimization [educational forum], IEEE
% Computational Intelligence Magazine, 2017, 12(4): 73-87".
%--------------------------------------------------------------------------

    arcobjs = (Archive.objs - zmin) ./ (zmax - zmin);  % normalization
    index = NDSort(arcobjs + rho_cone*sum(arcobjs,2), 1) == 1;
    Archive = Archive(index);
    arcobjs = arcobjs(index,:);
    PCObj = arcobjs;
    if isempty(Archive)
        return;
    else
        if length(Archive) > N
            % Determine the radius of the niche
            d  = pdist2(PCObj,PCObj);
            d(logical(eye(length(d)))) = inf;
            sd = sort(d,2);
            r  = median(sd(:,min(size(PCObj,2),size(sd,2))));
            R  = min(d./r,1);
            % Delete solution one by one
            while length(Archive) > N
                [~,worst]  = max(1-prod(R,2));
                Archive(worst)  = [];
                R(worst,:) = [];
                R(:,worst) = [];
            end         
        end
    end
end


function g = calSubpFitness(type, objs, z, W)
% Calculate the function values of the scalarization method
% 
%   Author: Ruihao Zheng
%   Last modified: 17/08/2022

    type2 = floor(type);
    switch type2
        case 1
            % weight sum approach
            switch round((type - type2) * 10)
                case 1
                    g = sum(objs ./ W, 2);
                case 2
                    g = sum((objs-z) .* W, 2);
                otherwise
                    g = sum(objs .* W, 2);
            end
        case 2
            % Tchebycheff approach
            switch round((type - type2) * 10)
                case 1
                    g = max(abs(objs-z) ./ W, [], 2);
                otherwise
                    g = max(abs(objs-z) .* W, [], 2);
            end
        case 7
            % p-norm scalarization
            if type - type2 == 0
                p = 2;
            else
                p = round((type - type2) * 1000, 2);  % p is only allowed to have two decimal places
            end
            if p == 2
                g = sum((abs(objs-z).* W).^p, 2).^(1/p);  % faster than vecnorm
            else
                g = vecnorm(abs(objs-z).* W, p, 2);
            end
    end
end
