classdef gMOEADGGR_EIE < ALGORITHM
% <multi/many> <real>
% gMOEA/D-GGR
% delta --- 0.8 --- The probability of selecting candidates from neighborhood
% p --- 1 --- The parameter p of GNS
% Tm --- 0.1 --- The mating neighborhood size
% Tr --- 0.001 --- The replacement neighborhood size
% tol --- 0.05 --- Parameter of the EWS method
% is_EIE --- 1 --- 

%------------------------------- Reference --------------------------------
% "A Generalized Scalarization Method for Evolutionary Multi-objective
% Optimization"
% https://github.com/EricZheng1024/MOEA-D-GGR
%--------------------------------------------------------------------------

    methods
        function main(Algorithm,Problem)
            %% Parameter setting
            [delta, p, Tm, Tr, tol, is_EIE] = Algorithm.ParameterSet(0.8, 1, 0.1, 0.001, 0.05, 1);
            if length(tol) == 1
                tol = tol*ones(1,Problem.M);
            end

            %% Init MOEA
            % Generate the weight vectors
            [W, Problem.N] = UniformPoint(Problem.N, Problem.M);
            Tm = ceil(Problem.N * Tm);
            Tr = ceil(Problem.N * Tr);
            % Detect the mating and replacement neighbors of each solution
            B = pdist2(W, W);
            W = 1./W ./ sum(1./W, 2);
            [~,B] = sort(B, 2);
            Bm = B(:, 1:Tm);
            % Generate random population
            Population = Problem.Initialization();
            % Initialize the reference point
            [zmin, I] = min(Population.objs, [], 1);
            % Dertermine the scalar function
            switch p
                case 1
                    type = 1.2;
                case inf
                    type = 2;
                otherwise
                    type = 7 + min(999, p)*0.001;
            end
            h = (prod(W,2).^(-1/Problem.M));
            % Repair the boundary weight generated by "UniformPoint"    not required since "W = 1./W ./ sum(1./W, 2);" 
            % zero_counter = sum(W<=1e-6, 2);
            % [~, I] = max(W, [], 2);
            % for i = 1 : Problem.N
            %     W(i, I(i)) = W(i, I(i)) - zero_counter(i)*1e-6;
            % end

            %% Init EIE
            % Parameters of CMA-ES
            if is_EIE
                state_CMAES = ones(1, Problem.M);  % ==1: activated; >=2: deactivated
            else
                state_CMAES = inf(1, Problem.M);
            end
            lambda_def = 4+floor(3*log(Problem.D));
            x_range = Problem.upper-Problem.lower;
            Sigma = struct('s',num2cell(1:Problem.M),'lambda',lambda_def,'m',num2cell(Population(I).decs,2)', ...
                'sigma',0.5*norm(diag(x_range)),'sigma_0',0.5*norm(diag(x_range)), ...  % 不能为0，会使得下次更新出现nan值
                'C',diag(x_range/norm(diag(x_range))),'diagD_0',(x_range/norm(diag(x_range))'), ...  % 考虑变量量纲不一致，并确保该对角阵二范数等于单位阵的二范数
                'p_c',0,'p_sigma',0,'gen',0,'gen_TolFun',0,'PSA_buff',[]);

            % Warm-start CMA-ES
            alpha = (tol*Problem.M) ./ (Problem.M-1-tol*(1-Problem.M));  % The meaning of alpha in the code differs slightly from that described in the paper; however, it is equivalent.
            WS_gamma = 0.1*ones(1,Problem.M);
            WS_alpha = 0.1*ones(1,Problem.M);
            objs_pop = Population.objs;
            objs_pop = normalize_2(objs_pop, zmin, max(Population.objs,[],1));
            objs_pop_trans = g_ews(objs_pop, objs_pop, alpha);
            for i = 1 : Problem.M
                [Sigma(i).m, Sigma(i).sigma, Sigma(i).C] = warm_start([Population.decs, objs_pop_trans(:,i)], WS_gamma(i), WS_alpha(i));
                Sigma(i).sigma_0 = Sigma(i).sigma;
                [~,D] = eig(Sigma(i).C);
                Sigma(i).diagD_0 = diag(D);
            end
            
            %% Optimization
            while Algorithm.NotTerminated(Population)
                % Generate offspring by EIE
                Offspring = [];
                Combine = cell(1, Problem.M);
                flag_inj = cell(1, Problem.M);
                for i = 1 : Problem.M
                    if state_CMAES(i) < 2
                        points_sampling = mvnrnd(Sigma(i).m,Sigma(i).sigma^2*Sigma(i).C,Sigma(i).lambda);
                        flag_inj{i} = any(points_sampling < Problem.lower, 2) | any(points_sampling > Problem.upper, 2);  % box constraints
                        Offspring_i = SOLUTION( min(max(points_sampling,Problem.lower),Problem.upper) );
                        Offspring = [Offspring Offspring_i];
                        Combine{i} = Offspring_i;
                    end
                end


                % Iteration of MOEA
                % Get the mating pool
                MatingPool = zeros(1, 2 * Problem.N);
                for i = 1 : Problem.N
                    % Choose the parents
                    if rand < delta
                        P = Bm(i, randperm(Tm));
                    else
                        P = randperm(Problem.N);
                    end
                    MatingPool(i) = P(1);
                    MatingPool(Problem.N + i) = P(2);
                end
                
                % Generate N offspring and merge all the offspring
                Offspring = [
                    Offspring, ...
                    OperatorDE(Population, ...
                               Population(MatingPool(1:length(MatingPool)/2)),Population(MatingPool(length(MatingPool)/2+1:end)), ...
                               {0.9,0.5,1,50})
                    ];

                % Replacement
                zmin = min([zmin; Offspring.objs]);
                zmax = max(Population.objs, [], 1);
                Pt = [Population Offspring];
                objs_n = normalize_2(Pt.objs, zmin, zmax);  % normalization
                g = zeros(length(Pt), Problem.N);
                for i = 1 : length(Pt)
                    g(i,:) = calSubpFitness(type, objs_n(i,:), zeros(1,Problem.M), W) .* h;
                end
                [~, I_subp] = min(g, [], 2);
                index_Pt = zeros(Problem.N, 1);
                select_counter = zeros(size(objs_n,1),1);
                for i = 1 : Problem.N
                    closest = find(I_subp==i & select_counter<Tr);
                    if isempty(closest)
                        index_Pt(i) = i;  % default
                        continue
                    end
                    [~, Ri] = min(g(closest, i));
                    index_Pt(i) = closest(Ri);
                    select_counter(closest(Ri)) = select_counter(closest(Ri)) + 1;
                end
                Population = Pt(index_Pt);


                % Update EIE
                objs_off = Offspring.objs;
                objs_off = normalize_2(objs_off, zmin, zmax);
                objs_off_trans = g_ews(objs_off, objs_off, alpha);
                [~, I] = sort(objs_off_trans, 1);
                for i = 1 : Problem.M
                    % Fitness value stagnation detection
                    if state_CMAES(i) < 2
                        if ~exist('sol_fitness_best', 'var')
                            sol_fitness_best = Offspring(I(1,:));
                        else
                            objs_sfb = sol_fitness_best(i).obj;
                            objs_sfb = normalize_2(objs_sfb, zmin, zmax);
                            objs_sfb_trans_part = g_ews(objs_sfb(i),objs_sfb,alpha(i));
                            if objs_sfb_trans_part > objs_off_trans(I(1,i),i)
                                sol_fitness_best(i) = Offspring(I(1,i));
                                objs_sfb = sol_fitness_best(i).obj;
                                objs_sfb = normalize_2(objs_sfb, zmin, zmax);
                                objs_sfb_trans_part = g_ews(objs_sfb(i),objs_sfb,alpha(i));
                            end
                            objs_comb = Combine{i}.objs;
                            objs_comb = normalize_2(objs_comb, zmin, zmax);
                            diff_comb_sfb = g_ews(objs_comb(:,i), objs_comb, alpha(i)) - objs_sfb_trans_part;
                            if all(diff_comb_sfb < 1e-3)  % default 1e-12
                                Sigma(i).gen_TolFun = Sigma(i).gen_TolFun + 1;
                            else
                                Sigma(i).gen_TolFun = 0;
                            end
                        end
                    end
                    % Inject good solutions from the other new solutions
                    if state_CMAES(i) < 2 && Sigma(i).lambda == lambda_def  % 首先快速收敛，之后为了避免陷入局部最优，不允许injection
                        objs_comb = Combine{i}.objs;
                        [~,ia_objs_comb,ib_objs_off_top] = intersect(objs_comb,objs_off(I(1:Sigma(i).lambda,i),:),'stable','rows');
                        if length(ia_objs_comb) < Sigma(i).lambda  % 不是该CMA-ES产生的好解的逻辑索引存在1
                            index_objs_off_top = I(1:Sigma(i).lambda,i);
                            Combine{i} = [Combine{i}(ia_objs_comb) Offspring(index_objs_off_top(setdiff(1:Sigma(i).lambda,ib_objs_off_top,'stable')))];
                            flag_inj{i} = [flag_inj{i}(ia_objs_comb); true(Sigma(i).lambda-length(ib_objs_off_top),1)];
                        end
                    end
                end
                for i = 1 : Problem.M
                    if state_CMAES(i) < 2
                        % Sort the offsprings and injected solutions
                        objs_comb = Combine{i}.objs;
                        objs_comb = normalize_2(objs_comb, zmin, zmax);
                        objs_comb_trans_part = g_ews(objs_comb(:,i), objs_comb, alpha(i));
                        [~,rank] = sort(objs_comb_trans_part);
                        % Update CMA-ES
                        [Sigma(i), exitflag] = update_CMAES(Sigma(i),Combine{i}(rank).decs,lambda_def,flag_inj{i}(rank));
                        switch exitflag
                            case 0
                            case {-1, 1}
                                switch exitflag
                                    case -1
                                        state_CMAES(i) = state_CMAES(i) + 1;
                                    case 1
                                        % need restart
                                end
                                Sigma(i).s = i;
                                objs_pop = Population.objs;
                                objs_pop = normalize_2(objs_pop, zmin, zmax);
                                objs_pop_trans_part = g_ews(objs_pop(:,i), objs_pop, alpha(i));
                                % Restart
                                % [~, I] = min(objs_pop_trans_part);
                                % Sigma(i).m = Population(I).dec;
                                % x_range = Problem.upper-Problem.lower;
                                % Sigma(i).sigma = 0.5*norm(diag(x_range));
                                % Sigma(i).C = diag(x_range/norm(diag(x_range)));
                                % Warm restart
                                [Sigma(i).m, Sigma(i).sigma, Sigma(i).C] = warm_start([Population.decs, objs_pop_trans_part], WS_gamma(i), WS_alpha(i));
                                Sigma(i).sigma_0 = Sigma(i).sigma;
                                [~,D] = eig(Sigma(i).C);
                                Sigma(i).diagD_0 = diag(D);
                        end
                    end
                end
            end
        end
    end
end


%%
function g = calSubpFitness(type, objs, z, W)
% Calculate the function values of the scalarization method
% 
%   Author: Ruihao Zheng
%   Last modified: 17/08/2022

    type2 = floor(type);
    switch type2
        case 1
            % weight sum approach
            switch round((type - type2) * 10)
                case 1
                    g = sum(objs ./ W, 2);
                case 2
                    g = sum((objs-z) .* W, 2);
                otherwise
                    g = sum(objs .* W, 2);
            end
        case 2
            % Tchebycheff approach
            switch round((type - type2) * 10)
                case 1
                    g = max(abs(objs-z) ./ W, [], 2);
                otherwise
                    g = max(abs(objs-z) .* W, [], 2);
            end
        case 7
            % p-norm scalarization
            if type - type2 == 0
                p = 2;
            else
                p = round((type - type2) * 1000, 2);  % p is only allowed to have two decimal places
            end
            if p == 2
                g = sum((abs(objs-z).* W).^p, 2).^(1/p);  % faster than vecnorm
            else
                g = vecnorm(abs(objs-z).* W, p, 2);
            end
    end
end
